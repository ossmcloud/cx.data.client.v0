'use strict';

const _path = require('path');
const _cx_data = require('cx-data');
const _cx_render = require('./cx-client-render');
const _cxSchema = require('./cx-client-schema');
const _cxConst = require('./cx-client-declarations');

const DTFSUtils = require('./svc.dtfs/cx-dtfs-utils');

class CXClientContext extends _cx_data.DBContext {
    #shops = null;
    #shopList = null;
    #role = null;
    #user = null;
    constructor(pool, credentials) {
        // TODO: get proper path like relative to or something
        super(pool, _path.join(__dirname, 'business'), credentials);

       
    }

    get user() {
        return this.#user;
    }
    get userName() {
        if (!this.#user) { return null; }
        return `${this.#user.firstName} ${this.#user.lastName}`;
    }
    get tUserId() {
        if (!this.#user) { return null; }
        return this.#user.loginId;
    }

    get role() {
        if (!this.#role) { return null; }
        return this.#role;
    } 
    get roleId() {
        if (!this.#role) { return 0; }
        return this.#role.id;
    } 
    get roleName() {
        if (!this.#role) { return ''    ; }
        return this.#role.name;
    }

    get shops() { return this.#shops };
    get shopList() { return this.#shopList; }

    async init() {

        var query = {
            sql: `
                    select * from cx_login where masterLoginId = @masterLoginId

                    select  s.*
                    from    cx_login_shop s
                    left outer join cx_login l on l.loginId = s.loginId
                    where   l.masterLoginId = @masterLoginId
                `,
            params: [
                { name: _cxSchema.cx_login.MASTERLOGINID, value: this.userId }
            ]
        }

        var response = await this.exec(query);
        if (response.first() == null) { throw new Error('Not Authorised'); }
        this.#user = response.first();
        this.#role = {
            id: response.first().roleId || 0,
        }
        this.#role.name = _cxConst.CX_ROLE.getName(this.#role.id);

        var _this = this;
        this.#shops = [];
        response.subResults[0].each(function (record, idx) {
            _this.#shops.push(record.shopId);
        });
        this.#shopList = `(${this.#shops.toString()})`;
        
    }

}




module.exports = {
    builder: _cx_data.builder,
    //
    CXClientContext: CXClientContext,
    DTFSUtils: DTFSUtils,
    //
    Schema: _cxSchema,
    Const: _cxConst,
    Render: _cx_render,
    //
    get: async function (options) {
        var dbConfig = options.dbConfig || options;
        var credentials = (options.dbConfig) ? options : null;

        var db_pool = await _cx_data.getPool(dbConfig);
        var cx = new CXClientContext(db_pool, credentials);
        await cx.init();
        return cx;
    },
    
    generateTransmissionID(svcName, accountId, shopId) {
        // TODO: IMPORTANT NOTE:
        //      the tran id has a tick time stamp, 13 digits
        //      plus we add an identifier for the type of service, the account id and shop id
        //      in addition the accountId and shopId are SQL index fields so could easily be larger than 19 digits long which is the max for big int
        //      SOLUTIONS:
        //          change the transmissionId field in SQL to varchar
        //              check implications for indexing and stuff
        //              benefit is that I could go like: 10-6-1-TIMETICKS or similar
        //          change the transmissionId field in SQL to 
        //              DECIMAL(38,0) (https://dba.stackexchange.com/questions/51536/datatype-bigger-than-bigint)

        // transmission session can be generated by a number of processes, we assign a simple ID for each one
        var svcId = '-10';
        if (svcName == 'dtfs') { svcId = '10'; }
        if (svcName == 'sage200') { svcId = '20'; }
        if (svcName == 'sage50') { svcId = '30'; }
        // also, each transmission relates to a single shop, so we append the shop id
        var transmissionId = svcId + accountId.toString() + shopId.toString();
        // we also use the system ticks we should make it unique
        transmissionId += (new Date()).getTime().toString();
        return transmissionId;
    }
}